library(httr)
library(rvest)

APIkey = 'RGAPI-b588d0d9-da65-4692-a6b1-8e3fa9b68eef'

getIDbySummonerName = function(name, APIkey){
  url = URLencode(paste0('https://kr.api.riotgames.com/lol/summoner/v4/summoners/by-name/',name,'?api_key=',APIkey))
  jsonObj = getJSONfromURL(url)
  jsonObj$accountId
}

getChampList = function(){
  url = 'https://ddragon.leagueoflegends.com/api/versions.json'
  latestVersion = unlist(getJSONfromURL(url))[1]
  cat("Champion ID version :",latestVersion, '\n')
  url = paste0('http://ddragon.leagueoflegends.com/cdn/',latestVersion,'/data/en_US/champion.json')
  jsonObj = getJSONfromURL(url)
  champs = jsonObj$data
  res = c()
  for(i in 1:length(champs)){
    res = rbind(res, c(champs[[i]]$key, champs[[i]]$id))
  }
  res = data.frame(res, stringsAsFactors = FALSE)
  colnames(res) = c("ChampID","ChampName")
  return(res)
}

getMatchList = function(accountId, APIkey, champion = NULL, queue = NULL, endTime = NULL, beginTime = NULL, endIndex = NULL, beginIndex = NULL){
  url = paste0('https://kr.api.riotgames.com/lol/match/v4/matchlists/by-account/', accountId, '?')
  
  if(!is.null(champion)){
    url = paste0(url, 'champion=', champion, '&')
  }
  
  if(!is.null(queue)){
    url = paste0(url, 'queue=', queue, '&')
  }
  
  if(!is.null(endTime)){
    url = paste0(url, 'endTime=', endTime, '&')
  }
  
  if(!is.null(beginTime)){
    url = paste0(url, 'beginTime=', beginTime, '&')
  }
  
  if(!is.null(endIndex)){
    url = paste0(url, 'endIndex=', endIndex, '&')
  }
  
  if(!is.null(beginIndex)){
    url = paste0(url, 'beginIndex=', beginIndex, '&')
  }
  
  url = paste0(url,'api_key=', APIkey)
  
  jsonObj = getJSONfromURL(url)
  
  # matches, startIndex, endIndex, totalGames  
  
  matches = jsonObj$matches
  
  matches = data.frame(matrix(unlist(matches), nrow = length(matches), byrow = T),stringsAsFactors=FALSE)
  colnames(matches) = c("platformId", "gameId", "champion", "queue", "season", "timestamp", 'role', 'lane')
  matches
}

getMatchInfo = function(matchId, APIkey){
  url = paste0('https://kr.api.riotgames.com/lol/match/v4/matches/', matchId, '?api_key=', APIkey)
  jsonObj = getJSONfromURL(url)
  
  # gameDuration
  gameDuration = jsonObj$gameDuration
  if(jsonObj$queueId == 420 || jsonObj$queueId == 430 || jsonObj$queueId == 440){
    # teams
    # teams = jsonObj$teams
    # Blueteam = teams[[1]]
    # Redteam = teams[[2]]
    
    # participants 
    participants = jsonObj$participants
    
    # stats = participants[[1]]$stats
    
    getMySummonerIdx = function(participantIdentities, accountId){
      for(i in 1:10){
        if(participantIdentities[[i]]$player$accountId == accountId) return(i)
      }
    }
    res = c()
    # Idx = getMySummonerIdx(jsonObj$participantIdentities, accountId)
    for(i in 1:10){
      p = participants[[i]]
      stats = p$stats
      timeline = p$timeline
      Champ = p$championId
      TowerDMG = stats$damageDealtToTurrets / gameDuration
      CounterJG = stats$neutralMinionsKilledEnemyJungle / gameDuration
      XPDiff = sum(unlist(timeline$xpPerMinDeltas))
      Win = p$stats$win
      res = rbind(res,c(Champ, TowerDMG, CounterJG, XPDiff, Win, matchId))
    }
    res = data.frame(res, stringsAsFactors = FALSE)
    colnames(res) = c("Champ", "TowerDMG", "CounterJG", "XPDiff", "Win", 'matchId')
    return(res)
    
    {
      # gameId
      # platformId
      # gameCreation
      # queueID
      # mapId
      # seasonId
      # gameVersion
      # gameMode
      # gameType
      # paricipantIdentities 
      
      # largestMultiKill -> HyperCarry
      # totalDamageDealtToChampions (/gameDuration) -> DPM -> Dealer
      # damageDealtToTurrets (/gameDuration) -> Tower Damage -> Splitter
      # totalDamageTaken (/gameDuration) -> DTPM -> Tanker
      # goldEarned (/gameDuration) -> GPM -> MoneyScrapper
      
      # turretKills, inhibitorKills -> Tower Damage -> Splitter
      # neutralMinionsKilledEnemyJungle -> Counter Jungle -> Splitter
      
      # firstBloodKill, firstBloodAssist -> Fast
      # firstTowerKill, firstBloodAssist -> Fast
      
      # timeline$xpDiffPerMinDeltas -> Splitter
      
    }
  }
  return(c())
  
  
  
}

getJSONfromURL = function(url){
  res = GET(url)
  jsonObj = res %>% 
    read_html() %>% 
    html_text() %>%
    jsonlite::parse_json()
  jsonObj
}

# queue Information : 

# 850 : AI

# 420 : Solo Rank
# 430 : Normal
# 440 : Team rank
# 450 : ARAM

changeIDtoName = function(matchres){
  matchres$Champ = sapply(unlist(matchres$Champ), function(i){ 
    champs[which(champs[,1]== i),2]
  })
  return(matchres)
}

# league api -> summonner list ( accountID ) -> matchlists -> matches -> Data

getSummonersName = function(APIkey, Tier = 'I', Rank = "DIAMOND"){
  url = paste0('https://kr.api.riotgames.com/lol/league/v4/entries/RANKED_SOLO_5x5/', Rank, '/', Tier, '?page=1&api_key=', APIkey)
  Summoners = getJSONfromURL(url)
  res = sapply(1:length(Summoners), function(i){
    Summoners[[i]]$summonerName
  })
  return(res)
}

Summoners = getSummonersName(APIkey)


res = c()

# 1 ~ 19 too many request
# 20 ~ 48  #??
# 49 비니 엉덩이 찰싹 -> 최정빈 사랑해 , ID 변경
# ~99 , Service unavailable ( 503 )
# 173 개준상 -> 남준상
# 180 시봉새야 -> ???

for(i in 181:length(Summoners)){
  cat(i, '\n')
  Sys.sleep(5)
  matches = getMatchList(accountId = getIDbySummonerName(Summoners[i], APIkey), APIkey)[1:30,]
  matchId = matches[,2]
  for(j in 1:nrow(matches)){
    Sys.sleep(1)
    res = rbind(res, getMatchInfo(matchId[j],APIkey))
  }
}
dim(res) # 48300 * 6

res = changeIDtoName(res)
res = res[which(!duplicated(res)),] # 47190 * 6
dim(res)

save(res, file='D1.RData')
load("D1.RData")

######

library(dplyr)
library(ggplot2)

res = res %>% select(-matchId) # remove matchId, 47190 * 5

res$TowerDMG = as.numeric(res$TowerDMG)
res$CounterJG = as.numeric(res$CounterJG)
res$XPDiff = as.numeric(res$XPDiff)

res = res %>% 
  group_by(Champ, Win) %>%
  summarise(TowerDMG = mean(TowerDMG), CounterJG = mean(CounterJG), XPDiff = mean(XPDiff))

# 294 * 5

# 
library(stringr)

getPositionInfo = function(data){
  d = c()
  for(i in 1:length(data)){
    if(!grepl('<a',data[i])){next}
    if(grepl('<i', data[i])){next}
    v = strsplit( strsplit(data[i], '"')[[1]], '/')[[2]]
    
    champName = v[3]
    position = v[5]
    
    d = rbind(d, c(champName, position))        
  }
  d[,1] = str_to_title(d[,1])
  d = data.frame(d, stringsAsFactors = FALSE)
  colnames(d) = c("champName", 'position')
  
  return(d)
}

tops = getPositionInfo(readLines('Tops.html'))

# DrMundo 
tops$champName[which(tops$champName == 'Drmundo')] = 'DrMundo'
res = res %>% filter(Champ %in% tops$champName) # 104 * 5

summary(res)
# normalize res
normalize = function(v){
  (v - mean(v))/sd(v)
}

res$TowerDMG = normalize(res$TowerDMG)
res$CounterJG = normalize(res$CounterJG)
res$XPDiff = normalize(res$XPDiff)

summary(res)

res[which(res$TowerDMG>0.6753 &res$CounterJG>0.4201 & res$XPDiff>0.58923),] # splitter
res[which(res$TowerDMG< -0.8161 &res$CounterJG< -0.6871 & res$XPDiff< -0.51858),] # teamplayer

res[which(res$TowerDMG>0.6753 &res$CounterJG>0.4201 & res$XPDiff>0.58923 & res$Win == TRUE),] # splitter
res[which(res$TowerDMG< -0.8161 &res$CounterJG< -0.6871 & res$XPDiff< -0.51858 & res$Win == TRUE),] # teamplayer

res[which(res$TowerDMG< 0 &res$CounterJG< 0 & res$XPDiff< 0 & res$Win == TRUE),] # Teamplayer

# Irelia, Jax, Kayle, Nocturne, Quinn, Tryndamere -> Splitter
# Karma, Maokai, Rumble -> Teamplayer

res = res %>% select(-Win) %>% transmute(Kiin = 2*TowerDMG + CounterJG + XPDiff) %>% arrange(desc(Kiin)) # Gnar 

topness = res %>% transmute(Kiin = TowerDMG + CounterJG + XPDiff) %>% arrange(desc(Kiin)) # Gnar 

topness = res %>% transmute(Kiin = 2*TowerDMG + CounterJG + XPDiff) %>% arrange(desc(Kiin)) # Gnar 

# winrate

load("D1.RData")
res$TowerDMG = as.numeric(res$TowerDMG)
res$CounterJG = as.numeric(res$CounterJG)
res$XPDiff = as.numeric(res$XPDiff)

winrate = res %>% 
  filter(Champ %in% tops$champName) %>% 
  group_by(Champ, Win) %>%
  summarise(total = n()) %>%
  group_by(Champ) %>% 
  mutate(WinRate = total / sum(total)) %>%
  filter(Win == TRUE) %>%
  select( -Win,  -total) %>%
  arrange(desc(WinRate))


winrate = res %>% 
  

load("D1.RData") 

res$TowerDMG = as.numeric(res$TowerDMG)
res$CounterJG = as.numeric(res$CounterJG)
res$XPDiff = as.numeric(res$XPDiff)

pickrate = res %>% 
  filter(Champ %in% tops$champName) %>% 
  group_by(Champ) %>%
  summarise(Picked = n()) %>%
  arrange(desc(Picked)) 
pickrate$Picked = normalize(pickrate$Picked)


myres = right_join(right_join(
  topness , winrate
), pickrate) %>% arrange(Champ)

save(myres,'D1Res.RData')


ggplot(myres, aes(x = Kiin, y = WinRate, size = Picked, color = Picked)) +
  geom_point(shape = 20) +
  theme(
    legend.position = 'none',
    plot.title = element_text(hjust = 0.5, size = 20),
    axis.title = element_text(size = 20),
    axis.text.x = element_text(size = 20),
    axis.text.y = element_text(size = 20)
  ) +
  ggtitle('EDA between Top / Winrate / Pickrate') +
  geom_hline(yintercept = median(myres$WinRate), linetype = 'dashed', color = '#feca57', size = 1.5) +
  geom_vline(xintercept = median(myres$Kiin), linetype='dashed', color = '#feca57', size = 1.5)

medKiin = median(myres$Kiin)
medWin = median(myres$WinRate)

FW = myres %>% filter(Kiin >= mf ) %>%  filter(WinRate >= mw ) %>% arrange(desc(Picked)) # fun win
NFW = myres %>% filter(Kiin <= mf ) %>%  filter(WinRate >= mw ) %>% arrange(desc(Picked)) # no fun win 
FNW = myres %>% filter(Kiin >= mf ) %>%  filter(WinRate <= mw ) %>% arrange(desc(Picked)) # fun no win
NFNW = myres %>% filter(Kiin <= mf ) %>%  filter(WinRate <= mw ) %>% arrange(desc(Picked)) # no fun no win

myres2 = data.frame(
  cbind(round(rbind(mean(FW$Picked), mean(NFW$Picked), mean(FNW$Picked), mean(NFNW$Picked)),3), 
        c('FW','NFW','FNW', 'NFNW')), stringsAsFactors = FALSE
)
colnames(myres2) = c("Pick", 'Type')

ggplot(myres2, aes(x = Type, y = Pick, fill = Type)) + 
  geom_bar(stat = 'identity', width = 0.6) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 20),
    axis.title = element_text(size = 20),
    axis.text.x = element_text(size = 20),
    axis.text.y = element_text(size = 20)
  ) +
  ggtitle('EDA between Type / Pickrate')

# cluster 
library(fields)

#f8766d red
#7cae00 green
#00bfc4 sky
#c77cff purple 

colLab <- function(n) {
  if (is.leaf(n)) {
    a <- attributes(n)
    labCol <- labelColors[clusMember[which(names(clusMember) == a$label)]]
    attr(n, "nodePar") <- c(a$nodePar, lab.col = labCol)
  }
  n
}

tree = hclust(dist(myres[,2:4]))
tree$labels = myres$Champ

labelColors = hcl.colors(6, palette = 'set 2')

clusMember = cutree(tree,6)

clusDendro = dendrapply(as.dendrogram(tree), colLab)

plot(clusDendro, horiz = TRUE)
